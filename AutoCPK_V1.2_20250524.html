<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>ATE CPK分析工具</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 引入 Font Awesome 用於 icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="./all.min.css">
    <style>
    /* 基础样式 */
    :root {
        --primary-color: #0071e3;
        --secondary-color: #1d1d1f;
        --success-color: #29823b;
        --danger-color: #d93025;
        --background-color: #f5f5f7;
        --surface-color: #ffffff;
        --border-color: #d2d2d7;
    }

    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
        margin: 0;
        padding: 40px;
        background: var(--background-color);
        color: var(--secondary-color);
        line-height: 1.5;
    }

    /* 标题样式 */
    h1 { 
        color: var(--secondary-color);
        text-align: center;
        font-size: 32px;
        margin-bottom: 48px;
        font-weight: 500;
        letter-spacing: -0.5px;
    }

    /* 按钮栏 */
    .button-bar {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 40px 0;
    }

    /* 输入框组 */
    .input-bar {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 16px;
        margin-bottom: 40px;
        flex-wrap: wrap;
        padding: 24px;
        background: var(--surface-color);
        border-radius: 18px;
        box-shadow: 0 2px 12px rgba(0,0,0,0.05);
    }

    /* 自定义输入框 */
    .custom-input {
        width: 80px;
        padding: 10px 14px;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        font-size: 14px;
        text-align: center;
        transition: all 0.2s;
        background: var(--surface-color);
    }

    .custom-input:focus {
        border-color: var(--primary-color);
        outline: none;
        box-shadow: 0 0 0 3px rgba(0,113,227,0.15);
    }

    /* 按钮样式 */
    .cpk-btn {
        padding: 12px 28px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: var(--primary-color);
        color: white;
    }

    .cpk-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,113,227,0.3);
    }

    /* 文件上传按钮 */
    .custom-file-label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 12px 24px;
        background: var(--surface-color);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .custom-file-label:hover {
        background: #f5f5f7;
    }

    /* 表格容器 */
    .container {
        background: var(--surface-color);
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        padding: 16px;
        margin: 0;  /* 靠左对齐 */
        max-width: 100%;  /* 横向占满 */
        overflow-x: auto;  /* 添加横向滚动 */
    }

    /* 表格样式 */
    table {
        width: auto;  /* 自适应宽度 */
        border-collapse: separate;
        border-spacing: 0;
        margin: 12px 0;
        font-size: 12px;  /* 减小字体大小 */
        white-space: nowrap;  /* 防止文本换行 */
    }

    th, td {
        padding: 6px 8px;  /* 减小单元格内边距 */
        border: 1px solid var(--border-color);
        text-align: center;
        min-width: 70px;  /* 减小最小列宽 */
        line-height: 1.2;  /* 减小行高 */
    }

    /* 数字单元格对齐方式 */
    td:not(:first-child) {
        font-family: 'Consolas', monospace;  /* 等宽字体更适合数字 */
        padding: 6px 4px;  /* 数字列可以更窄一些 */
    }

    /* 第一列样式 */
    td:first-child, th:first-child {
        position: sticky;  /* 固定第一列 */
        left: 0;
        background: var(--surface-color);
        z-index: 1;
        font-size: 11px;  /* 第一列字体可以更小 */
        min-width: 100px;  /* 第一列稍宽一些 */
    }

    /* 特殊行样式 */
    tr[data-type="max-spec"] td, 
    tr[data-type="cpu"] td {
        background-color: #fff8e6;
    }

    tr[data-type="min-spec"] td, 
    tr[data-type="cpl"] td {
        background-color: #f0f7ed;
    }

    td.pass {
        background-color: var(--success-color) !important;
        color: white;
    }

    td.fail {
        background-color: var(--danger-color) !important;
        color: white;
    }

    /* AI聊天框 */
    #ai-chat-box {
        position: fixed;
        top: 24px;
        right: 24px;
        width: 340px;
        background: var(--surface-color);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.12);
        padding: 20px;
        display: none;  /* 添加这行，默认隐藏 */
    }

    #ai-chat-drag {
        color: var(--primary-color);
        font-size: 15px;
        font-weight: 500;
    }

    #ai-chat-input {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        font-size: 14px;
        margin: 12px 0;
    }

    /* 响应式设计 */
    @media (max-width: 768px) {
        body { padding: 20px; }
        .input-bar { 
            flex-direction: column;
            padding: 16px;
        }
        .container { padding: 16px; }
        #ai-chat-box { width: 300px; }
    }
    </style>
    <script src="./xlsx.full.min.js"></script>
    <script src="./html2canvas.min.js"></script>
</head>
<body>
    <h1><i class="fa-solid fa-chart-column icon"></i>CPK 分析工具</h1>
    <!-- 引入 Font Awesome 用於 icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <!-- 10个文字框，后面跟“執行CPK”按钮 -->
    <div class="input-bar" style="display:flex; justify-content:center; gap:12px; margin-bottom:24px;">
        <!-- 上傳Excel按钮放在最前面 -->
        <label class="custom-file-label" for="excelUpload" style="margin-right:24px;">
            <i class="fa-solid fa-file-excel icon" style="color:#217346"></i>上傳 Excel
            <input type="file" id="excelUpload" accept=".xlsx, .xls">
        </label>
        <!-- 隱藏上傳Word/RTF按钮 -->
        <label class="custom-file-label" for="wordUpload" style="display:none;">
            <i class="fa-solid fa-file-word icon" style="color:#185abd"></i>上傳 Word/RTF
            <input type="file" id="wordUpload" accept=".docx, .rtf">
        </label>
        <!-- CH1~CH10 -->
        <input type="text" class="custom-input" placeholder="CH1">
        <input type="text" class="custom-input" placeholder="CH2">
        <input type="text" class="custom-input" placeholder="CH3">
        <input type="text" class="custom-input" placeholder="CH4">
        <input type="text" class="custom-input" placeholder="CH5">
        <input type="text" class="custom-input" placeholder="CH6">
        <input type="text" class="custom-input" placeholder="CH7">
        <input type="text" class="custom-input" placeholder="CH8">
        <input type="text" class="custom-input" placeholder="CH9">
        <input type="text" class="custom-input" placeholder="CH10">
        <button id="confirmBtn" class="cpk-btn" style="margin-left:24px;background:#38761d; display:none;">
            <i class="fa-solid fa-check icon"></i>確認
        </button>
        <button id="executeCpkBtn" class="cpk-btn" style="margin-left:24px;">
            <i class="fa-solid fa-gears icon"></i>執行 CPK
        </button>
    </div>
    <!-- 導出按鈕放在下方 -->
    <div class="button-bar" style="justify-content:center; gap:24px; margin-bottom:32px;">
        <button id="exportCpkBtn" class="cpk-btn" style="background:#185abd;">
            <i class="fa-solid fa-download icon"></i>導出CPK
        </button>
        <button id="exportImgBtn" class="cpk-btn" style="background:#e69138;">
            <i class="fa-solid fa-image icon"></i>導出圖片
        </button>
    </div>
    <div class="container">
        <div class="preview-section">
            <div id="tableContainer"></div>
        </div>
    </div>
    <div id="ai-chat-box">
        <div id="ai-chat-drag" style="cursor:move;font-weight:bold;color:#185abd;margin-bottom:8px;user-select:none;">
            <i class="fa-solid fa-robot"></i> AI詢問聊天
        </div>
        <div id="ai-chat-history" style="height:120px;overflow-y:auto;background:#fff;border:1px solid #b5c6e0;border-radius:4px;padding:8px 12px;margin-bottom:8px;font-size:15px;"></div>
        <div style="display:flex;gap:8px;">
            <input id="ai-chat-input" type="text" placeholder="請輸入您的問題..." style="flex:1;padding:6px 10px;border:1px solid #b5c6e0;border-radius:4px;font-size:15px;">
            <button id="ai-chat-send" class="cpk-btn" style="background:#185abd;padding:6px 18px;font-size:15px;">
                <i class="fa-solid fa-paper-plane"></i> 發送
            </button>
        </div>
    </div>
    <!-- 在 body 标签开始处添加 -->
<div style="position: fixed; left: 24px; top: 24px; z-index: 101;">
    <button onclick="window.location.href='./CPK index.html'" class="cpk-btn" style="padding: 6px 12px; font-size: 14px; background: #f0f0f0; color: #333; border: 1px solid #ddd;">
        <i class="fa-solid fa-house"></i> 返回主頁
    </button>
</div>
    <!-- 在 body 开头附近添加这个按钮 -->
<div style="position: fixed; right: 24px; top: 24px; z-index: 101; display: flex; gap: 12px; align-items: center;">
    <!-- 帮助按钮 -->
    <i class="fa-solid fa-circle-question"
       style="font-size: 24px; color: var(--primary-color); cursor: pointer;"
       title="1.點擊導入Excel，導入Chromra ATE Data
2.輸入Testlog對應每組訊號
3.點擊"執行CPK"
4.點擊"導出CPK"或"導出圖片""></i>
    <!-- 语言选择 -->
    <select id="langSelect" class="cpk-btn" style="padding: 6px 12px; font-size: 14px; background: #f0f0f0; color: #333; border: 1px solid #ddd;">
        <option value="zh-TW">繁體中文</option>
        <option value="en">English</option>
        <option value="vi">Tiếng Việt</option>
    </select>
    <!-- AI聊天按钮 -->
    <button id="toggleChatBtn" class="cpk-btn" style="padding: 6px 12px; font-size: 14px; background: #f0f0f0; color: #333; border: 1px solid #ddd;">
        <i class="fa-solid fa-comments"></i> 顯示AI聊天
    </button>
</div>
    <script>
// 将全局变量声明移到最前面
let excelData = null;
let tableContainer = null;

document.addEventListener('DOMContentLoaded', function() {
    tableContainer = document.getElementById('tableContainer');
});

const translations = {
    'zh-TW': {
        title: 'CPK 分析工具',
        uploadExcel: '上傳 Excel',
        executeCpk: '執行 CPK',
        exportCpk: '導出CPK',
        exportImage: '導出圖片',
        showAiChat: '顯示AI聊天',
        hideAiChat: '隱藏AI聊天',
        aiChat: 'AI詢問聊天',
        inputPlaceholder: '請輸入您的問題...',
        send: '發送',
        help: '1.點擊導入Excel，導入Chromra ATE Data\n2.輸入Testlog對應每組訊號\n3.點擊"執行CPK"\n4.點擊"導出CPK"或"導出圖片"',
        uploadFirst: '請先上傳並計算 CPK！'
    },
    'en': {
        title: 'CPK Analysis Tool',
        uploadExcel: 'Upload Excel',
        executeCpk: 'Execute CPK',
        exportCpk: 'Export CPK',
        exportImage: 'Export Image',
        showAiChat: 'Show AI Chat',
        hideAiChat: 'Hide AI Chat',
        aiChat: 'AI Chat',
        inputPlaceholder: 'Enter your question...',
        send: 'Send',
        help: '1. Click to import Excel and import Chromra ATE Data\n2. Enter signal groups corresponding to Testlog\n3. Click "Execute CPK"\n4. Click "Export CPK" or "Export Image"',
        uploadFirst: 'Please upload and calculate CPK first!'
    },
    'vi': {
        title: 'Công cụ Phân tích CPK',
        uploadExcel: 'Tải lên Excel',
        executeCpk: 'Thực hiện CPK',
        exportCpk: 'Xuất CPK',
        exportImage: 'Xuất ảnh',
        showAiChat: 'Hiện AI Chat',
        hideAiChat: 'Ẩn AI Chat',
        aiChat: 'Hỏi đáp AI',
        inputPlaceholder: 'Nhập câu hỏi của bạn...',
        send: 'Gửi',
        help: '1. Nhấp để nhập Excel, nhập Chromra ATE Data\n2. Nhập tín hiệu tương ứng với Testlog\n3. Nhấp "Thực hiện CPK"\n4. Nhấp "Xuất CPK" hoặc "Xuất ảnh"',
        uploadFirst: 'Vui lòng tải lên và tính CPK trước!'
    }
};

// 工具函数
function findRowIdx(data, name) {
    return data.findIndex(row => String(row[0]).toUpperCase().trim() === name.toUpperCase());
}
function findRowIdxByCell(data, keyword) {
    return data.findIndex(row => row.some(cell => String(cell).includes(keyword)));
}
function safeParse(v) {
    return isNaN(parseFloat(v)) ? 0 : parseFloat(v);
}

// Excel上传处理函数
function handleExcelUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            excelData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            // 显示预览
            displayTable(excelData);
        } catch (error) {
            console.error('Excel processing error:', error);
            alert('Excel 處理出錯，請檢查文件格式！');
        }
    };
    reader.readAsArrayBuffer(file);
}

// 表格显示函数
function displayTable(data) {
    if (!data || !data.length) return;
    
    const tableContainer = document.getElementById('tableContainer');
    tableContainer.innerHTML = '';
    const table = document.createElement('table');
    
    data.forEach((row, rowIdx) => {
        const tr = document.createElement('tr');
        row.forEach((cell, colIdx) => {
            const td = document.createElement('td');
            if (typeof cell === 'number') {
                td.textContent = cell.toFixed(3);
            } else {
                td.textContent = cell || '';
            }
            tr.appendChild(td);
        });
        table.appendChild(tr);
    });
    
    tableContainer.appendChild(table);
}

// Excel上传
document.getElementById('excelUpload').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        excelData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        displayTable(excelData);
    };
    reader.readAsArrayBuffer(file);
});

// 表格预览渲染
function displayTable(data) {
    const tableContainer = document.getElementById('tableContainer');
    tableContainer.innerHTML = '';
    const table = document.createElement('table');
    data.forEach((row, rowIdx) => {
        const tr = document.createElement('tr');
        const firstCell = (row[0] || '').toString().toUpperCase().trim();
        const isMergeRow = (row[0] === 'Test Item' || row[0] === 'Test Condition');
        if (isMergeRow) {
            let col = 0;
            while (col < row.length) {
                let colspan = 1;
                while (
                    col + colspan < row.length &&
                    row[col] !== undefined &&
                    row[col] === row[col + colspan]
                ) colspan++;
                const td = document.createElement('td');
                td.textContent = row[col] ?? '';
                if (colspan > 1) td.colSpan = colspan;
                tr.appendChild(td);
                col += colspan;
            }
            table.appendChild(tr);
            return;
        }
        row.forEach((cell, idx) => {
            const td = document.createElement('td');
            if (typeof cell === 'number' && !isNaN(cell)) {
                td.textContent = cell.toFixed(3);
            } else if (!isNaN(parseFloat(cell)) && cell !== '' && cell !== null) {
                td.textContent = Number(cell).toFixed(3);
            } else {
                td.textContent = cell ?? '';
            }
            // 恢复颜色
            if (firstCell === 'MAX_SPEC' || firstCell === 'CPU') {
                td.style.backgroundColor = '#ffe599';
            } else if (firstCell === 'MIN_SPEC' || firstCell === 'CPL') {
                td.style.backgroundColor = '#d9ead3';
            } else if (firstCell === 'CONCLUSION') {
                if (idx > 0 && cell === 'PASS') {
                    td.style.backgroundColor = '#38761d';
                    td.style.color = '#fff';
                } else if (idx > 0 && cell === 'FAIL') {
                    td.style.backgroundColor = '#e06666';
                    td.style.color = '#fff';
                }
            }
            tr.appendChild(td);
        });
        table.appendChild(tr);
    });
    tableContainer.appendChild(table);
}

// Word/RTF上传（如不用可注释）
document.getElementById('wordUpload')?.addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const fileType = file.name.split('.').pop().toLowerCase();
        if (fileType === 'docx') {
            mammoth.extractRawText({ arrayBuffer: e.target.result })
                .then(result => displayWordContent(result.value))
                .catch(err => console.error("Error reading Word file:", err));
        }
        // RTF功能已去除
    };
    reader.readAsArrayBuffer(file);
});
function displayWordContent(content) {
    const wordPreview = document.getElementById('wordPreview');
    wordPreview.innerHTML = '';
    const paragraph = document.createElement('div');
    paragraph.innerHTML = content;
    wordPreview.appendChild(paragraph);
}

// “確認”按钮功能
document.getElementById('confirmBtn').addEventListener('click', function() {
    const inputs = document.querySelectorAll('.input-bar .custom-input');
    const values = Array.from(inputs).map(input => input.value.trim());
    let html = '<table style="margin-top:20px;"><tr>';
    for (let i = 0; i < values.length; i++) html += `<th>CH${i+1}</th>`;
    html += '</tr><tr>';
    for (let v of values) html += `<td>${v || ''}</td>`;
    html += '</tr></table>';
    let exist = document.getElementById('chTablePreview');
    if (!exist) {
        exist = document.createElement('div');
        exist.id = 'chTablePreview';
        document.querySelector('.input-bar').after(exist);
    }
    exist.innerHTML = html;
});

// “執行CPK”按钮功能
document.getElementById('executeCpkBtn').addEventListener('click', function() {
    // 替換S/N行中的 _1_ ~ _10_，保留“_”
    const chInputs = document.querySelectorAll('.input-bar .custom-input');
    const chValues = Array.from(chInputs).map(input => input.value.trim());
    if (excelData && excelData.length > 0) {
        const snRowIdx = excelData.findIndex(row => row.some(cell => String(cell).toUpperCase().includes('S/N')));
        if (snRowIdx !== -1) {
            for (let i = 0; i < chValues.length; i++) {
                const target = `_${i + 1}_`;
                const value = chValues[i];
                for (let col = 0; col < excelData[snRowIdx].length; col++) {
                    if (typeof excelData[snRowIdx][col] === 'string' && excelData[snRowIdx][col].includes(target)) {
                        excelData[snRowIdx][col] = excelData[snRowIdx][col].replaceAll(target, `_${value}_`);
                    }
                }
            }
        }
    }

    // 在 S/N 行中，每个单元格只保留第二个下划线前的内容（第二根下划线也删除）
    const snRowIdx = excelData.findIndex(row => row.some(cell => String(cell).toUpperCase().includes('S/N')));
    if (snRowIdx !== -1) {
        for (let col = 0; col < excelData[snRowIdx].length; col++) {
            let cell = excelData[snRowIdx][col];
            if (typeof cell === 'string') {
                // 找到第二个下划线的位置
                let firstIdx = cell.indexOf('_');
                let secondIdx = cell.indexOf('_', firstIdx + 1);
                if (secondIdx !== -1) {
                    // 保留第二个下划线之前的内容（不包含第二根下划线）
                    excelData[snRowIdx][col] = cell.substring(0, secondIdx);
                }
            }
        }
    }

    // 工具函数
    const findRowIdx = (data, name) => data.findIndex(row => String(row[0]).toUpperCase().trim() === name.toUpperCase());
    const findRowIdxByCell = (data, keyword) => data.findIndex(row => row.some(cell => String(cell).includes(keyword)));
    const safeParse = v => isNaN(parseFloat(v)) ? 0 : parseFloat(v);

    // 1. 保留 "S/N" 的上一行及其后内容
    const snRowIndex = findRowIdxByCell(excelData, 'S/N');
    if (snRowIndex === -1) {
        alert('未找到含有 "S/N" 的行！');
        return;
    }
    let filteredData = excelData.slice(Math.max(0, snRowIndex - 1));

    // 2. 在 S/N 上一行的下一行插入空白行，并命名
    if (filteredData.length > 0) {
        const emptyRow = Array(filteredData[0].length).fill('');
        emptyRow[0] = 'Test Condition';
        filteredData.splice(1, 0, emptyRow);
    }

    // 3. 在 MAX_SPEC 那一行前插入 Lowest、Hightest、Xbar、S
    const insertRowsBefore = (arr, idx, names) => {
        for (let i = 0; i < names.length; i++) {
            const newRow = Array(arr[0].length).fill('');
            newRow[0] = names[i];
            arr.splice(idx + i, 0, newRow);
        }
    };
    let maxSpecIdx = findRowIdxByCell(filteredData, 'MAX_SPEC');
    if (maxSpecIdx !== -1) {
        insertRowsBefore(filteredData, maxSpecIdx, ['Lowest', 'Hightest', 'Xbar', 'S']);
    }

    // 4. 在 MIN_SPEC 那一行后插入6行
    const minSpecIdx = findRowIdxByCell(filteredData, 'MIN_SPEC');
    if (minSpecIdx !== -1) {
        const names = ['Ca', 'Cp', 'CPL', 'CPU', 'CPK', 'Conclusion'];
        for (let i = 0; i < names.length; i++) {
            const newRow = Array(filteredData[0].length).fill('');
            newRow[0] = names[i];
            filteredData.splice(minSpecIdx + 1 + i, 0, newRow);
        }
    }

    // 5. 第一行第一格输入 "Test Item"
    if (filteredData[0]?.length) filteredData[0][0] = 'Test Item';

    // 6. 剪切所有括号里的内容到“Test Condition”行，并删除“Test Item”行的所有括号及内容
    if (filteredData.length > 1) {
        for (let col = 0; col < filteredData[0].length; col++) {
            const cell = filteredData[0][col];
            if (typeof cell === 'string') {
                const matches = [...cell.matchAll(/[（(]([^）)]+)[）)]/g)];
                if (matches.length > 0) {
                    filteredData[1][col] = matches.map(m => m[0]).join('');
                    filteredData[0][col] = cell.replace(/[（(][^）)]+[）)]/g, '').trim();
                }
            }
        }
    }

    // 7. 删除第二列中等于 0 的行
    filteredData = filteredData.filter((row, idx) => idx === 0 || row[1] !== 0);

    // 8. 删除列的条件：
    // 1) 整列（除表头外）全为0的列要删除
    // 2) S/N下一行到Lowest上一行中，全为0、1或2的列也要删除
    if (filteredData.length > 0) {
        const snIdx = findRowIdx(filteredData, 'S/N');
        const lowestIdx = findRowIdx(filteredData, 'Lowest');
        
        if (snIdx !== -1 && lowestIdx !== -1) {
            const keepCols = [];
            for (let col = 0; col < filteredData[0].length; col++) {
                let shouldKeep = false;
                let hasNonZeroOneTwoVal = false;

                // 检查整列是否全为0（除表头外）
                for (let row = 1; row < filteredData.length; row++) {
                    const val = filteredData[row][col];
                    if (val !== 0 && val !== '0' && val !== '' && val !== null) {
                        shouldKeep = true;
                    }
                }

                // 检查S/N下一行到Lowest上一行是否全为0、1或2
                for (let row = snIdx + 1; row < lowestIdx; row++) {
                    const val = Number(filteredData[row][col]);
                    if (val !== 0 && val !== 1 && val !== 2) {
                        hasNonZeroOneTwoVal = true;
                        break;
                    }
                }

                // 只有满足以下条件才保留该列：
                // 1) 不是整列都为0
                // 2) S/N到Lowest之间不是全为0、1或2
                if (shouldKeep && hasNonZeroOneTwoVal) {
                    keepCols.push(col);
                }
            }
            filteredData = filteredData.map(row => keepCols.map(col => row[col]));
        }
    }

    // 9. 删除 MAX_SPEC & MIN_SPEC 行中同一列同时为 "*" 或空白的列
    maxSpecIdx = findRowIdxByCell(filteredData, 'MAX_SPEC');
    const minSpecIdx2 = findRowIdxByCell(filteredData, 'MIN_SPEC');
    if (maxSpecIdx !== -1 && minSpecIdx2 !== -1) {
        const keepCols = [];
        for (let col = 0; col < filteredData[0].length; col++) {
            const maxCell = filteredData[maxSpecIdx][col];
            const minCell = filteredData[minSpecIdx2][col];
            const isMaxEmptyOrStar = maxCell == null || String(maxCell).trim() === '' || String(maxCell).trim() === '*';
            const isMinEmptyOrStar = minCell == null || String(minCell).trim() === '' || String(minCell).trim() === '*';
            if (!(isMaxEmptyOrStar && isMinEmptyOrStar)) keepCols.push(col);
        }
        filteredData = filteredData.map(row => keepCols.map(col => row[col]));
    }

    // 10. 计算 Lowest 行
    const lowestRowIdx = findRowIdx(filteredData, 'Lowest');
    const snIdx = findRowIdxByCell(filteredData, 'S/N');
    if (lowestRowIdx !== -1 && snIdx !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            let min = null;
            for (let row = snIdx + 1; row < lowestRowIdx; row++) {
                const val = safeParse(filteredData[row][col]);
                if (!isNaN(val)) {
                    if (min === null || val < min) min = val;
                }
            }
            if (min !== null) filteredData[lowestRowIdx][col] = min;
        }
    }

    // 11. 计算 Hightest 行
    const hightestRowIdx = findRowIdx(filteredData, 'Hightest');
    if (hightestRowIdx !== -1 && snIdx !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            let max = null;
            for (let row = snIdx + 1; row < hightestRowIdx; row++) {
                const val = safeParse(filteredData[row][col]);
                if (!isNaN(val)) {
                    if (max === null || val > max) max = val;
                }
            }
            if (max !== null) filteredData[hightestRowIdx][col] = max;
        }
    }

    // 12. 计算 Xbar 行
    const xbarRowIdx = findRowIdx(filteredData, 'Xbar');
    if (xbarRowIdx !== -1 && lowestRowIdx !== -1 && snIdx !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            let sum = 0, count = 0;
            for (let row = snIdx + 1; row < lowestRowIdx; row++) {
                const val = safeParse(filteredData[row][col]);
                if (!isNaN(val)) {
                    sum += val;
                    count++;
                }
            }
            if (count > 0) filteredData[xbarRowIdx][col] = sum / count;
        }
    }

    // 13. 计算 S 行（总体标准差）
    const sRowIdx = findRowIdx(filteredData, 'S');
    if (sRowIdx !== -1 && lowestRowIdx !== -1 && snIdx !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            let values = [];
            for (let row = snIdx + 1; row < lowestRowIdx; row++) {
                const val = safeParse(filteredData[row][col]);
                if (!isNaN(val)) values.push(val);
            }
            if (values.length > 0) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
                filteredData[sRowIdx][col] = Math.sqrt(variance);
            }
        }
    }

    // 14. 计算 Ca 行
    const caRowIdx = findRowIdx(filteredData, 'Ca');
    const xbarRowIdx2 = findRowIdx(filteredData, 'Xbar');
    const maxSpecIdx2 = findRowIdx(filteredData, 'MAX_SPEC');
    const minSpecIdx3 = findRowIdx(filteredData, 'MIN_SPEC');
    if (caRowIdx !== -1 && xbarRowIdx2 !== -1 && maxSpecIdx2 !== -1 && minSpecIdx3 !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            const xbar = safeParse(filteredData[xbarRowIdx2][col]);
            let maxSpec = safeParse(filteredData[maxSpecIdx2][col]);
            let minSpec = safeParse(filteredData[minSpecIdx3][col]);
            if ((maxSpec - minSpec) !== 0) {
                const ca = Math.abs(
                    (xbar - (maxSpec + minSpec) / 2) / ((maxSpec - minSpec) / 2)
                );
                filteredData[caRowIdx][col] = ca;
            }
        }
    }

    // 15. 计算 Cp 行
    const cpRowIdx = findRowIdx(filteredData, 'Cp');
    const sRowIdx2 = findRowIdx(filteredData, 'S');
    const maxSpecIdx3 = findRowIdx(filteredData, 'MAX_SPEC');
    const minSpecIdx4 = findRowIdx(filteredData, 'MIN_SPEC');
    if (cpRowIdx !== -1 && sRowIdx2 !== -1 && maxSpecIdx3 !== -1 && minSpecIdx4 !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            let maxSpec = safeParse(filteredData[maxSpecIdx3][col]);
            let minSpec = safeParse(filteredData[minSpecIdx4][col]);
            const s = safeParse(filteredData[sRowIdx2][col]);
            if (s !== 0) {
                const cp = Math.abs((maxSpec - minSpec) / (6 * s));
                filteredData[cpRowIdx][col] = cp;
            }
        }
    }

    // 16. 计算 CPL 行：(Xbar-MIN_SPEC)/(3*S)，只在 MIN_SPEC 有值时才计算
    const cplRowIdx = findRowIdx(filteredData, 'CPL');
    const xbarRowIdx3 = findRowIdx(filteredData, 'Xbar');
    const sRowIdx3 = findRowIdx(filteredData, 'S');
    const minSpecIdx5 = findRowIdx(filteredData, 'MIN_SPEC');
    if (
        cplRowIdx !== -1 &&
        xbarRowIdx3 !== -1 &&
        sRowIdx3 !== -1 &&
        minSpecIdx5 !== -1
    ) {
        for (let col = 1; col < filteredData[0].length; col++) {
            const xbar = parseFloat(filteredData[xbarRowIdx3][col]);
            const minSpec = parseFloat(filteredData[minSpecIdx5][col]);
            const s = parseFloat(filteredData[sRowIdx3][col]);
            // 只有 MIN_SPEC 有值才计算
            if (
                !isNaN(xbar) &&
                !isNaN(minSpec) &&
                !isNaN(s) && s !== 0
            ) {
                filteredData[cplRowIdx][col] = (xbar - minSpec) / (3 * s);
            }
        }
    }

    // 17. 计算 CPU 行：((MAX_SPEC-Xbar)/(3*S))，只在 MAX_SPEC 有值时计算
    const cpuRowIdx = findRowIdx(filteredData, 'CPU');
    const maxSpecIdx5 = findRowIdx(filteredData, 'MAX_SPEC');
    const xbarRowIdx4 = findRowIdx(filteredData, 'Xbar');
    const sRowIdx4 = findRowIdx(filteredData, 'S');
    if (
        cpuRowIdx !== -1 &&
        maxSpecIdx5 !== -1 &&
        xbarRowIdx4 !== -1 &&
        sRowIdx4 !== -1
    ) {
        for (let col = 1; col < filteredData[0].length; col++) {
            const maxSpec = parseFloat(filteredData[maxSpecIdx5][col]);
            const xbar = parseFloat(filteredData[xbarRowIdx4][col]);
            const s = parseFloat(filteredData[sRowIdx4][col]);
            // 只有 MAX_SPEC 有值才计算
            if (
                !isNaN(maxSpec) &&
                !isNaN(xbar) &&
                !isNaN(s) && s !== 0
            ) {
                filteredData[cpuRowIdx][col] = (maxSpec - xbar) / (3 * s);
            }
        }
    }

    // 18. 计算 CPK 行：MIN(CPL, CPU)
    const cpkRowIdx = findRowIdx(filteredData, 'CPK');
    const cplRowIdx2 = findRowIdx(filteredData, 'CPL');
    const cpuRowIdx2 = findRowIdx(filteredData, 'CPU');
    if (cpkRowIdx !== -1 && cplRowIdx2 !== -1 && cpuRowIdx2 !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            const cpl = parseFloat(filteredData[cplRowIdx2][col]);
            const cpu = parseFloat(filteredData[cpuRowIdx2][col]);
            if (!isNaN(cpl) && !isNaN(cpu)) {
                filteredData[cpkRowIdx][col] = Math.min(cpl, cpu);
            } else if (!isNaN(cpl)) {
                filteredData[cpkRowIdx][col] = cpl;
            } else if (!isNaN(cpu)) {
                filteredData[cpkRowIdx][col] = cpu;
            }
            // 若都不是数字则不赋值
        }
    }

    // 19. 计算 Conclusion 行：CPK>=1.67 显示 PASS，否则 FAIL
    const conclusionRowIdx = findRowIdx(filteredData, 'Conclusion');
    const cpkRowIdx2 = findRowIdx(filteredData, 'CPK');
    if (conclusionRowIdx !== -1 && cpkRowIdx2 !== -1) {
        for (let col = 1; col < filteredData[0].length; col++) {
            const cpk = parseFloat(filteredData[cpkRowIdx2][col]);
            if (!isNaN(cpk)) {
                filteredData[conclusionRowIdx][col] = cpk >= 1.67 ? 'PASS' : 'FAIL';
            }
        }
    }

    // 在所有计算完成后，显示表格之前，删除所有"*"字符
    if (filteredData.length > 0) {
        for (let row = 0; row < filteredData.length; row++) {
            for (let col = 0; col < filteredData[row].length; col++) {
                const cell = filteredData[row][col];
                if (typeof cell === 'string') {
                    // 删除单元格中的所有"*"字符
                    filteredData[row][col] = cell.replace(/\*/g, '');
                }
            }
        }
    }

    // 显示处理后的表格
    displayTable(filteredData);
    excelData = filteredData;

    alert('已完成以下操作：\n1. 刪除含有 "S/N" 前面的所有行，但保留 "S/N" 的上一行。\n2. 在 S/N 上一行插入空白行並命名。\n3. 在 MAX_SPEC 前插入 Lowest、Hightest、Xbar、S。\n4. 在 MIN_SPEC 後插入6行。\n5. 在第一行第一格輸入 Test Item。\n6. 剪切括號內容到 Test Condition。\n7. 刪除第二列中等於 0 的行。\n8. 刪除表格中含有0的列。\n9. 刪除 MAX_SPEC & MIN_SPEC 行中“*”或者空白的列（需同時滿足）。\n10. 計算 Lowest 行。\n11. 計算 Hightest 行。\n12. 計算 Xbar 行。\n13. 計算 S 行（整體標準差）。');
});

// 導出Excel
document.getElementById('exportCpkBtn').addEventListener('click', function() {
    if (!excelData || excelData.length === 0) {
        alert('請先上傳並計算 CPK！');
        return;
    }
    const exportData = JSON.parse(JSON.stringify(excelData));
    const findRowIdx = (data, name) => data.findIndex(row => String(row[0]).toUpperCase().trim() === name.toUpperCase());
    const snRowIdx = findRowIdx(exportData, 'S/N');
    const lowestRowIdx = findRowIdx(exportData, 'Lowest');
    const hightestRowIdx = findRowIdx(exportData, 'Hightest');
    const xbarRowIdx = findRowIdx(exportData, 'Xbar');
    const sRowIdx = findRowIdx(exportData, 'S');
    const maxSpecIdx = findRowIdx(exportData, 'MAX_SPEC');
    const minSpecIdx = findRowIdx(exportData, 'MIN_SPEC');
    const caRowIdx = findRowIdx(exportData, 'Ca');      // ← 新增
    const cpRowIdx = findRowIdx(exportData, 'Cp');      // ← 新增
    const cplRowIdx = findRowIdx(exportData, 'CPL');
    const cpuRowIdx = findRowIdx(exportData, 'CPU');
    const cpkRowIdx = findRowIdx(exportData, 'CPK');
    const conclusionRowIdx = findRowIdx(exportData, 'Conclusion');

    const ws = XLSX.utils.aoa_to_sheet(exportData);

    // 居中和三位小数
    for (let row = 0; row < exportData.length; row++) {
        for (let col = 0; col < exportData[0].length; col++) {
            const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
            const cell = ws[cellAddress];
            if (cell) {
                cell.s = { alignment: { horizontal: "center", vertical: "center" } };
                if (typeof cell.v === 'number') {
                    cell.v = Number(cell.v.toFixed(3));
                    cell.z = '0.000';
                }
                if (cell.f) cell.z = '0.000';
            }
        }
    }

    // 公式赋值（含MIN_SPEC/MAX_SPEC判斷）
    for (let col = 1; col < exportData[0].length; col++) {
        const colLetter = XLSX.utils.encode_col(col);
        // Lowest
        if (lowestRowIdx !== -1 && snRowIdx !== -1) {
            const start = colLetter + (snRowIdx + 2);
            const end = colLetter + (lowestRowIdx);
            ws[colLetter + (lowestRowIdx + 1)] = { f: `MIN(${start}:${end})`, z: '0.000' };
        }
        // Hightest
        if (hightestRowIdx !== -1 && snRowIdx !== -1) {
            const start = colLetter + (snRowIdx + 2);
            const end = colLetter + (hightestRowIdx);
            ws[colLetter + (hightestRowIdx + 1)] = { f: `MAX(${start}:${end})`, z: '0.000' };
        }
        // Xbar
        if (xbarRowIdx !== -1 && lowestRowIdx !== -1 && snRowIdx !== -1) {
            const start = colLetter + (snRowIdx + 2);
            const end = colLetter + (lowestRowIdx);
            ws[colLetter + (xbarRowIdx + 1)] = { f: `AVERAGE(${start}:${end})`, z: '0.000' };
        }
        // S
        if (sRowIdx !== -1 && lowestRowIdx !== -1 && snRowIdx !== -1) {
            const start = colLetter + (snRowIdx + 2);
            const end = colLetter + (lowestRowIdx);
            ws[colLetter + (sRowIdx + 1)] = { f: `STDEVA(${start}:${end})`, z: '0.000' };
        }
        // CPL
        if (cplRowIdx !== -1 && xbarRowIdx !== -1 && sRowIdx !== -1 && minSpecIdx !== -1) {
            const xbarCell = colLetter + (xbarRowIdx + 1);
            const sCell = colLetter + (sRowIdx + 1);
            const minSpecCell = colLetter + (minSpecIdx + 1);
            const minSpecValue = exportData[minSpecIdx][col];
            if (minSpecValue !== '' && minSpecValue !== null && !isNaN(Number(minSpecValue))) {
                ws[colLetter + (cplRowIdx + 1)] = { f: `(${xbarCell}-${minSpecCell})/(3*${sCell})`, z: '0.000' };
            } else {
                ws[colLetter + (cplRowIdx + 1)] = { v: '' };
            }
        }
        // CPU
        if (cpuRowIdx !== -1 && maxSpecIdx !== -1 && xbarRowIdx !== -1 && sRowIdx !== -1) {
            const maxSpecCell = colLetter + (maxSpecIdx + 1);
            const xbarCell = colLetter + (xbarRowIdx + 1);
            const sCell = colLetter + (sRowIdx + 1);
            const maxSpecValue = exportData[maxSpecIdx][col];
            if (maxSpecValue !== '' && maxSpecValue !== null && !isNaN(Number(maxSpecValue))) {
                ws[colLetter + (cpuRowIdx + 1)] = { f: `(${maxSpecCell}-${xbarCell})/(3*${sCell})`, z: '0.000' };
            } else {
                ws[colLetter + (cpuRowIdx + 1)] = { v: '' };
            }
        }
        // CPK
        if (cpkRowIdx !== -1 && cplRowIdx !== -1 && cpuRowIdx !== -1) {
            const cplCell = colLetter + (cplRowIdx + 1);
            const cpuCell = colLetter + (cpuRowIdx + 1);
            ws[colLetter + (cpkRowIdx + 1)] = { f: `MIN(${cplCell},${cpuCell})`, z: '0.000' };
        }
        // Conclusion
        if (conclusionRowIdx !== -1 && cpkRowIdx !== -1) {
            const cpkCell = colLetter + (cpkRowIdx + 1);
            ws[colLetter + (conclusionRowIdx + 1)] = { f: `IF(${cpkCell}>=1.67,"PASS","FAIL")` };
        }
        // Ca
        if (caRowIdx !== -1 && xbarRowIdx !== -1 && maxSpecIdx !== -1 && minSpecIdx !== -1) {
            const xbarCell = colLetter + (xbarRowIdx + 1);
            const maxSpecCell = colLetter + (maxSpecIdx + 1);
            const minSpecCell = colLetter + (minSpecIdx + 1);
            ws[colLetter + (caRowIdx + 1)] = {
                f: `ABS((${xbarCell}-(${maxSpecCell}+${minSpecCell})/2)/ ( (${maxSpecCell}-${minSpecCell})/2 ) )`,
                z: '0.000'
            };
        }
        // Cp
        if (cpRowIdx !== -1 && sRowIdx !== -1 && maxSpecIdx !== -1 && minSpecIdx !== -1) {
            const maxSpecCell = colLetter + (maxSpecIdx + 1);
            const minSpecCell = colLetter + (minSpecIdx + 1);
            const sCell = colLetter + (sRowIdx + 1);
            ws[colLetter + (cpRowIdx + 1)] = {
                f: `ABS((${maxSpecCell}-${minSpecCell})/(6*${sCell}))`,
                z: '0.000'
            };
        }
    }

    // 合并“Test Item”和“Test Condition”行相同内容的单元格
    const merges = [];
    [0, 1].forEach(rowIdx => {
        const row = exportData[rowIdx];
        let col = 0;
        while (col < row.length) {
            let colspan = 1;
            while (
                col + colspan < row.length &&
                row[col] !== undefined &&
                row[col] === row[col + colspan]
            ) colspan++;
            if (colspan > 1) {
                merges.push({
                    s: { r: rowIdx, c: col },
                    e: { r: rowIdx, c: col + colspan - 1 }
                });
            }
            col += colspan;
        }
    });
    ws['!merges'] = merges;

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "CPK結果");
    XLSX.writeFile(wb, "CPK結果.xlsx");
});

// 導出圖片
document.getElementById('exportImgBtn').addEventListener('click', function() {
    const tableContainer = document.getElementById('tableContainer');
    if (!tableContainer || tableContainer.innerHTML.trim() === '') {
        alert('請先上傳並計算 CPK！');
        return;
    }
    html2canvas(tableContainer, {
        backgroundColor: '#fff',
        scale: 2
    }).then(function(canvas) {
        const link = document.createElement('a');
        link.download = 'CPK表格.jpg';
        link.href = canvas.toDataURL('image/jpeg', 1.0);
        link.click();
    });
});

document.getElementById('ai-chat-send').addEventListener('click', function() {
    const input = document.getElementById('ai-chat-input');
    const history = document.getElementById('ai-chat-history');
    const question = input.value.trim();
    if (!question) return;
    // 显示用户问题
    history.innerHTML += `<div style="color:#333;margin-bottom:4px;"><b>你：</b>${question}</div>`;
    input.value = '';
    // 模拟AI回复（实际应用需接API）
    setTimeout(() => {
        history.innerHTML += `<div style="color:#38761d;margin-bottom:8px;"><b>AI：</b>很抱歉，當前為演示模式，暫不支持真實AI對話。</div>`;
        history.scrollTop = history.scrollHeight;
    }, 600);
});

// 聊天框拖动功能
(function() {
    const box = document.getElementById('ai-chat-box');
    const drag = document.getElementById('ai-chat-drag');
    let offsetX = 0, offsetY = 0, dragging = false;

    drag.addEventListener('mousedown', function(e) {
        dragging = true;
        // 鼠标点在窗口内的偏移
        offsetX = e.clientX - box.getBoundingClientRect().left;
        offsetY = e.clientY - box.getBoundingClientRect().top;
        document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', function(e) {
        if (dragging) {
            let x = e.clientX - offsetX;
            let y = e.clientY - offsetY;
            // 限制不出屏幕
            x = Math.max(0, Math.min(window.innerWidth - box.offsetWidth, x));
            y = Math.max(0, Math.min(window.innerHeight - box.offsetHeight, y));
            box.style.left = x + 'px';
            box.style.top = y + 'px';
            box.style.right = 'auto';
        }
    });
    document.addEventListener('mouseup', function() {
        dragging = false;
        document.body.style.userSelect = '';
    });
})();

// AI聊天框显隐切换
document.getElementById('toggleChatBtn').addEventListener('click', function() {
    const chatBox = document.getElementById('ai-chat-box');
    const isHidden = chatBox.style.display === 'none';
    chatBox.style.display = isHidden ? 'block' : 'none';
    this.innerHTML = isHidden ? 
        '<i class="fa-solid fa-comments"></i> 隱藏AI聊天' : 
        '<i class="fa-solid fa-comments"></i> 顯示AI聊天';
});

// 语言切换功能
document.getElementById('langSelect').addEventListener('change', function() {
    const lang = this.value;
    updateLanguage(lang);
    
    // 保存语言选择到 localStorage（可选）
    localStorage.setItem('preferred-language', lang);
});

// 添加语言切换函数
function updateLanguage(lang) {
    const t = translations[lang];
    
    // 更新标题
    document.querySelector('h1').innerHTML = `<i class="fa-solid fa-chart-column"></i>${t.title}`;
    
    // 更新按钮文本
    document.querySelector('.custom-file-label').innerHTML = 
        `<i class="fa-solid fa-file-excel icon" style="color:#217346"></i>${t.uploadExcel}<input type="file" id="excelUpload" accept=".xlsx, .xls">`;
    document.getElementById('executeCpkBtn').innerHTML = 
        `<i class="fa-solid fa-gears icon"></i>${t.executeCpk}`;
    document.getElementById('exportCpkBtn').innerHTML = 
        `<i class="fa-solid fa-download icon"></i>${t.exportCpk}`;
    document.getElementById('exportImgBtn').innerHTML = 
        `<i class="fa-solid fa-image icon"></i>${t.exportImage}`;
    
    // 更新帮助提示
    document.querySelector('.fa-circle-question').title = t.help;
    
    // 更新AI聊天相关文本
    document.getElementById('ai-chat-drag').innerHTML = 
        `<i class="fa-solid fa-robot"></i> ${t.aiChat}`;
    document.getElementById('ai-chat-input').placeholder = t.inputPlaceholder;
    document.getElementById('ai-chat-send').innerHTML = 
        `<i class="fa-solid fa-paper-plane"></i> ${t.send}`;
    
    // 更新按钮状态文本
    const toggleBtn = document.getElementById('toggleChatBtn');
    const isHidden = document.getElementById('ai-chat-box').style.display === 'none';
    toggleBtn.innerHTML = isHidden ? 
        `<i class="fa-solid fa-comments"></i> ${t.showAiChat}` : 
        `<i class="fa-solid fa-comments"></i> ${t.hideAiChat}`;
}

// DOMContentLoaded 事件中统一初始化
document.addEventListener('DOMContentLoaded', function() {
    // 初始化语言
    updateLanguage('zh-TW');
    
    // 绑定事件监听器（确保只绑定一次）
    initEventListeners();
});

// 将所有事件监听器初始化函数集中管理
function initEventListeners() {
    // Excel上传
    document.getElementById('excelUpload').addEventListener('change', handleExcelUpload);
    
    // 执行CPK
    document.getElementById('executeCpkBtn').addEventListener('click', executeCPK);
    
    // 导出功能
    document.getElementById('exportCpkBtn').addEventListener('click', exportToExcel);
    document.getElementById('exportImgBtn').addEventListener('click', exportToImage);
    
    // AI聊天
    document.getElementById('toggleChatBtn').addEventListener('click', toggleAIChat);
    document.getElementById('ai-chat-send').addEventListener('click', handleAIChat);
    
    // 语言切换
    document.getElementById('langSelect').addEventListener('change', function(e) {
        updateLanguage(e.target.value);
    });
}

// 在处理数据的步骤中添加：删除所有单元格中的"*"字符
if (filteredData.length > 0) {
    for (let row = 0; row < filteredData.length; row++) {
        for (let col = 0; col < filteredData[row].length; col++) {
            const cell = filteredData[row][col];
            if (typeof cell === 'string') {
                // 删除单元格中的所有"*"字符
                filteredData[row][col] = cell.replace(/\*/g, '');
            }
        }
    }
}
    </script>
</body>
</html>
